# 1. 리눅스 특징
## 실시간 페이지 적재 기능(Demand Loading Excutables)
<pre>
-> 리눅스를 사용하면서 메모리를 페이지 단위로 관리하는 것을 뜻한다.
</pre>
## CPU 최적화
<pre>
-> 리눅스는 강력한 하드웨어 적응형으로서 인텔 계열의 프로세서를 비롯하여, Crix와 AMD 프로세서에도 최적화되어 있다.
   또한, CPU 각각의 하드웨어적인 문제들을 해결하기 위한 장치들이 마련되어 있따.
   따라서 어떤 프로세서를 사용하더라도 최고의 성능을 이끌어 낼 수 있다.
</pre>
## 뛰어난 네트워킹
<pre>
-> 다른 OS에 비해 강력한 네트워킹을 지원한다. 완벽한 TCP/IP의 구현을 비롯하여 IPX/SPC, 애플토크, SLIP(Serial Line IP), PPP, Bluetooth등
   여러 네트워킹 프로토콜을 지원하며 각종 네트워킹 서비스들을 제공한다.
   리눅스를 설치하고 넷마스크, 도메인 이름, IP 주소, 게이트웨이 등 몇 가지 설정만 마치면 바로 네트워크 서버로 사용할 수 있으며,
   이더넷 및 인터넷에 안정적 연결이 가능하다.
</pre>
## 가상 콘솔
<pre>
-> 가상 콘솔(Virtual Console)이라는 것은 개인이 사용하는 하나의 PC의 물리적인 모니터 하나로 여러 개의 가상화면을 두는 기능이다.
   기본적으로 여섯 개의 가상 콘솔이 설정되어 있어 각 창마다 서로 다른 작업을 진행 할 수 있다.
</pre>
## POSIX의 완벽한 호환
<pre>
-> 유닉스의 시스템 표준화 인터페이스에서 정의한 POSIX 표준과 호환을 이루는 것으로 상업용 유닉스 소스코드를 전혀 사용하지 않고
   개발되어 왔기 때문에 리눅스는 유닉스에 종속되지 않는다.
</pre>
## 트리(Tree) 형태의 계층적 구조의 파일 시스템
<pre>
-> 파일 시스템은 '/' 즉, 루트에서 시작된다. 그리고 모든 디바이스는 이 아래에 연결이 된다.
   다른 파티션의 경우 마운트(mount) 명령으로 연결된다.
   따라서 도스나 윈도우의 경우 모든 파티션이 독립적으로 존재하는 것과 다른 특징을 가지게 된다.
</pre>
## 효율적인 가상 메모리
<pre>
-> 가상 메모리는 하드 디스크를 진짜 메모리(RAM)처럼 사용하는 방법으로 쓸 수 있는 전체 메모리 사이즈르 크게 하는 기능으로서
   메모리를 효율적으로 사용하도록 도와준다. 이 기능이 리눅스에서 효과적으로 지원된다. 
</pre>
## 동적 공유 라이브러리 제공
<pre>
-> 리눅스의 큰 특징 중 하나로, 동적 공유 라이브러리(Dynamic Shared Library)는 프로그램 마다 특별한 목적을 가지고 고유한 기능을 수행하지만
   대부분 프로그램에 꼭 들어가는 공통적인 기능들에 대해 여러 프로그램이 동일하게 사용하는 코드에 대해 각자 따로 가지지 않고 이를 공유하는
   라이브러리를 지원하는데 이런 기능을 통칭 '라이브러리' 기능이라고 한다.
   정적 라이브러리(Static Library)는 컴파일 할 때 프로그램에 넣지만 
   동적 공유 라이브러리(Dynamic Shared Library)는 실행 파일 내부에 항상 넣어두지 않고 프로그램마다 실행 도중에 가져다 쓰므로
   경제적이고 효율성이 굉장히 높다.
</pre>
## 완벽한 다중 사용자, 다중 작업 시스템
<pre>
-> 리눅스는 시분할(Time Sharing)로 동시에 여러 개의 프로세스를 실행할 수 있으며 
   하나의 시스템을 여러 명의 사용자가 동시에 사용할 수 있는 시스템이다.
</pre>
## 최신 웹서비스 제공
<pre>
-> 클러스터링, 클라우드, 가상화 등 최신의 웹서비스에서 필요로 하는 대부분의 기능과 성능을 가지고 있다.
   '리눅스 클러스터링'은 인터넷 게임, 포털 서비스 등 대형 서버 시스템을 필요로 하는 경우에 사용되며
   클러스터링, 가상화 등의 기술을 통해 클라우드 서비스를 제공할 수 있다.
</pre>
# 2. 리눅스 장점
## 이식성과 확장성이 용이하다.
<pre>
-> 리눅스는 거의 대부분의 C언어와, 어셈블리 언어로 작성되어 있다.
   C언어 자체가 특정 기계에 비의존적이기 때문에 프로그램을 다른 기계의 시스템으로 포팅하는 것이 쉽다.
   이런 이유 때문에 OS 자체도 하드웨어에 적합하게 변형이 가능하며, x86 용으로 개발된 리눅스가 SPARC나 맥dml Power PC, Alpha 등에 
   모두 적용될 수 있게 되었다.
</pre>
## 텍스트 모드 중심의 관리와 다양한 관리 환경의 제공
<pre>
-> Dos처럼 텍스트 모드로 관리해야 하고, 편의성 측면에서 큰 단점으로 보일 수 있다.
   하지만, 리눅스는 직접 설정 파일을 수정하여 세밀한 시스템의 설정이 가능하고 소스코드를 수정해 프로그램을 시스템에 최적화 시킬 수 있다.
   또한, 윈도우 등의 GUI 기반의 OS와 다르게 프로그램을 일일히 실행시켜 설정을 저장하게 하는 등의 번거로움을 벗어나서
   간단한 파일 수정 작업을 몇 개의 명령어 실행만으로도 간편하게 할 수 있다는 장점이 있다.
   또한, 간단한 스크립트 파일을 작성하여 자유롭게 시스템을 자동화 시킬수 있다는 장점이 있다.
   게다가 요즘은 리눅스 시스템도 GUI 프로그램을 제공하며 웹서비스를 이용하여 시스템의 관리와 모니터링을 쉽게 할 수 있기 때문에
   다양한 관리 도구의 사용으로 인한 편리함을 누릴수 있다.
</pre>
## 풍부한 소프트웨어 개발 환경 제공
<pre>
-> 유닉스 시스템과 리눅스 시스템은 거의 모든 프로그래밍 언어를 제공한다.
   특히 GNU 소프트웨어가 무료로 제공되면서 값비싼 프로그래밍 툴을 사용하지 않아도 되면서 모든 프로그래밍 툴이 무료로 제공되었다.
   또한, 모든 시스템의 소스가 개발되어 있기 때문에 소프트웨어 개발에 개방적이다.
</pre>
## 다양한 네트워크 서비스 및 작업환경 지원
<pre>
-> 오픈 소스 소프트웨어 형태로 제공되는 많은 프로그램을 사용하여 다양한 웹서비스를 구축 및 서비스 할 수 있고 웹을 통한 작업환경 구축이 가능하다.
</pre>
## 뛰어난 안정성
<pre>
-> 리눅스는 C언어 기반이므로 프로그래밍과 포팅에 용이하다. 
   또한, 국제적이고 개발적인 개발 환경을 가지고 있으므로 커널 및 응용 프로그램에 중대한 버그가 있을 경우 상업적 소프트웨어에 
   비하여 신속하게 이에 대한 패치가 개발되어 공개된다.
   또한 커널, 파일 시스템, 쉘(Shell), 웹서비스 프로그램 등 리눅스 시스템의 기반이 되는 모든 프로그램이 소스코드가 공개되어 있어
   직접 시스템을 최적화 할 수 있다.
   이러한 점에서 리눅스 시스템의 안정성이 매우 뛰어나다고 말할 수 있다.
</pre>
## 시스템 보안성
<pre>
-> 물론 리눅스의 공개 코드 상에서 보안상 문제로 지적되는 경우가 있지만
   리눅스 커널은 상당한 기간 동안의 연구, 전세계의 개발자들로부터의 의견 수렴 및 지속적으로 거쳐 완성되기 때문에 
   기본적인 완성도가 높고, 리눅스 시스템의 대부분의 프로그램은 소스코드가 공개되어 있기 때문에 프로그램의 오류를 빠르게 확인하여
   이에 대한 패치를 제공하고 보안 문제와 이에 대한 해결방안도 빠르게 보고되므로 관리자가 주의를 기울이기만 한다면 
   보안 문제가 비교적 용이하게 해결된다.
   따라서, 그 어느 OS보다도 보안성이 뛰어나다고 할 수 있다.
</pre>
## 폭넓은 하드웨어 장치 지원
<pre>
-> 리눅스 커널이 공개되어 있고, 전세계의 다양한 분야의 개발자들이 참여하여 왔으며 하드웨어 관련 기업들의 참여가 확산되어 왔다.
   이에 따라 리눅스 커널은 폭넓은 하드웨어 장치들을 지원하는 드라이버들을 포함하고 있다.
</pre>
## 저수준 하드웨어로 구성된 시스템의 사용 가능
<pre>
-> 리눅스는 서버 시스템으로 사용하기 위한 최소한의 설치를 하면 하드 디스크를 차지하는 전체 운영체제의 용량이 적고 요구하는 하드디스크의 성능도 높지 않다.
   따라서, 구형 컴퓨터에서도 서버 시스템의 운영이 가능하다.
   또한, 리눅스 커널은 모듈 방식을 적재하여 사용할 수 있고, 소스코드가 공개되어 있기 때문에 최적화도 용이하다.
   따라서, 저수준 하드웨어를 갖춘 시스템에서 리눅스는 최적 성능 발휘가 가능하며 다양한 분야의 임베디드 및 휴대용 기기의 운영체제로 사용되고 있다.
</pre>
## 시스템의 높은 신뢰성
<pre>
-> 리눅스는 RAID 기능을 지원하고 로컬 또는 인터넷을 통한 다양한 백업 방식을 지원한다.
   ext3, ext4 등의 파일 시스템은 fsck 등의 명령을 통해 안정적인 시스템 복구 기능을 지원한다.
   따라서 리눅스 시스템은 서버 시스템으로서 높은 신뢰성을 가지고 있다.
</pre>
## 가성비
<pre>
-> 리눅스는 비용을 들이지 않아도 CentOs, Debian 등 다양한 종류의 리눅스를 다운로드하여 설치 및 사용이 가능하다.
   이러한 리눅스 운영체제는 고가의 서버 운영체제와 비교하여 전혀 손색이 없고 리눅스 서버 관리자의 역량에 따라
   유료 서비스를 받지 않더라도 서버 시스템의 운영이 가능하다.
   
   * 단, 서버 시스템의 경우 상당한 가격에 거래가 되기도 한다. 
         이런 가격들은 주로 리눅스 시스템의 업데이트, 컨설팅 및 유지보수 서비스에 관한 비용으로 책정된 것이다.
</pre>
# 3. 사용자 및 그룹 관리
##  관련 폴더
<pre>
-> /etc/passwd : 시스템에 등록된 사용자 정보
-> /etc/shadow : 시스템에 등록된 사용자의 패스워드와 패스워드에 대한 설정
-> /etc/group : 시스템에 등록된 그룹정보
-> /etc/gshadow : 시스템에 등록된 그룹의 패스워드와 패스워드에 대한 설정
-> /etc/skel : 뼈대라는 의미로 사용자에 대한 기본적인 초기화 파일들을 저장하고 있는 디렉토리
-> /etc/login.defs : 사용자나 그룹을 생성할 때 참고하는 기본 값들이 저장되어 있음
-> /etc/sudoers : sudo 명령을 사용하기 위한 조건이 있는 파일
-> /var/log/secure : 인증과 관련된 로그를 담는 파일
</pre>
## 사용자 생성관리 명령어
<pre>
-> useradd [option] user-name : 사용자 생성
    -> useradd -D : 기본 설정 확인
    -> ex) useradd -u 2000 -g 10 -m -d /home/guest/user03 -s /bin/sh user03
-> usermod [option] user-name : 사용자 정보 수정
-> userdel [option] user-name : 사용자 삭제
</pre>
## 그룹 생성관리 명령어
<pre>
-> groupadd [option] group-name : 그룹 생성
-> groupmod [option] group-name : 그룹 정보 수정
-> groupdel group-name : 그룹 삭제
</pre>
## 기타 권한 명령어
<pre>
-> su [-] [user-name] : 사용자 전환
    -> ex) sudo -i : 루트 사용자 전환
-> sudo [option] [user-name] command : 로그아웃을 하지않고 특정 사용자 권한으로 수행
-> chage [option] [argument] user-name :  /etc/shadow 파일에서 패스워드의 속성을 변경하는 명령어
</pre>
# 4. 고급 권한 관리
<pre>
-> 개념 : 대부분의 경우, 읽기, 쓰기, 실행과 같은 기본 권한을 설정하여 파일에 대한 접근을 제어할 수 있지만,
         일부 특수한 목적으로 사용되는 파일은 기본 권한만으로 파일에 대한 접근을 제어하기 어려울 수도 있다.
         이를 해결하기 위해 확장 권한을 사용한다.

 -> setuid : 파일을 실행하는 주체가 파일을 실행한 사용자가 아닌 파일을 소유하고 있는 사용자의 권한으로 프로세스를 실행하게 된다.
    -> ex) chmod 4000

 -> setgid : 명령을 실행할 때 프로세스의 사용자 그룹이 파일의 사용자 그룹으로 실행된다.
    -> ex) chmod 2000
 
 -> sticky bit : 파일을 소유한 사용자만 파일을 삭제할 수 있다.
     -> ex) chmod 1000
</pre>
 ## 접근 제어 리스트(Access Control List, ACL)
 <pre>
-> 리눅스의 파일 권한은 사용자, 사용자 그룹, 기타 사용자로 분류되고 각각 읽기, 쓰기, 실행 권한이 제공된다.
   이 권한 체계로 파일을 관리하는데 큰 문제는 없다.
   하지만, 권한을 세부적으로 설정할 수 없다는 단점이 존재한다.
   ACL을 사용하면 파일을 소유한 사용자와 사용자 그룹을 제외한 사용자와 그룹에게 별도로 권한을 부여 할 수 있다.
-> getfacl file-name : 접근 제어 리스트 정보 확인
-> setfacl [option] ENTRY:NAME:PERMS file-name : 접근 제어 리스트 설정
    -> ex) setfacl -m u:user01:rwx /root/acl/dirA
    -> ex) setfacl -x g:group01 /root/acl/dirA #권한제거
    -> ex) setfacl -RM u:user01:rwx /root/acl/dirA #재귀적 사용
</pre>
# 5. 작업 스케줄링
<pre>
-> at [option] time-spec : 단일성 작업 예약\
-> crontab -e : 주기적인 작업 예약
</pre>
# 6. 디스크 관리
<pre>
-> fdisk file-name : 파티션 구성 디스크 명령어
</pre>
# 7. 파일시스템 및 스왑 메모리
<pre>
-> 파일시스템 : 구조화된 일련의 정보를 구성하는 파일과 디렉토리의 집합, 파일 및 디렉토리를 저장하는 방식
    -> ex) mkfs -t [filesystem-type] partition : 파일시스템 생성하는 명령

-> 마운트(mount) : 파일시스템을 생성한 후에는 파일시스템이 생성된 파티션 장치에 접근할 수 있도록 경로를 생성해야 한다.
                  파일시스템이 생성된 파티션 장치에서 데이터를 읽거나 쓸 때 일일이 장치 파일을 통해서 접근하는 방식은 매우 불편하다.
                  그렇기 때문에 파일시스템이 생성된 파티션에 디렉토리 형태로 접근할 수 있도록 연결하는 작업을 수행하는데 이를 마운트라고 한다.
                  -> ex) mount [option] {partition | UUID} mount-point
                  -> ex) umount [option] {partition | nount-point | UUID}
                  
-> blkid : 파일시스템 정보 확인
</pre>
## 리눅스 파일시스템
### 디스크 기반 파일시스템(Disk-Based File System)
<pre>
-> EXT : 리눅스 초기 개발 시 리눅스에서 사용하기 위하여 만들어진 확장 파일시스템이다.
         현재 ext파일시스템은 ext2,ext3,ext4 세가지 버전이 존재한다.
-> XFS : RHEL7, CentOS7, OL7 등 최신 리눅스 버전에서 기본 파일시스템으로 사용되고 있는 파일시스템
-> FAT : USB등 이동식 저장장치에 주로 사용되고 있는 파일 시스템
</pre>
### 분산 파일시스템(Distributed File System)
<pre>
-> NFS(Network File System) : 대부분 유닉스/리눅스에서 사용할 수 있는 분산파일시스템 방식.
                              공유된 자원을 로컬 시스템의 자원처럼 사용할 수 있다.
-> SMB(Server Message Block) : 파일 및 장치 공유 프로토콜인 'SMB'기반의 분산파일시스템이다.
                               윈도우 운영체제와 유닉스/리눅스 운영체제간 디렉토리 및 파일 공유기능을 제공한다.
                               리눅스에서는 삼바(Samba)서비스를 통해 SMB 공유를 제공할 수 있다.
</pre>
### Pseudo 파일 시스템
<pre>
-> Pseudo 파일 시스템은 메모리 기반의 파일시스템으로 시스템 성능을 높이고 커널정보에 접근할 수 있도록 지원한다.
-> swapfs : 스왑 파일 시스템(Swap file System)은 물리 메모리를 보조하기 위한 디스크 내의 스왑영역에서 사용하는 파일 시스템이다.
-> tmpfs : 임시 파일시스템은 디스크 기반의 쓰기 오버헤드를 줄이기 위해 메모리에 파일을 기록하는 시스템
-> fdfs : 파일 설명자 파일시스템은 /dev/fd 디렉토리의 파일 설명자를 사용할 수 있는 명시적인 이름을 제공하고 있다.
-> procfs : 현재 동작중인 프로세스의 목록을 관리하는 파일시스템
-> devfs : 시스템에서 사용하는 모든 디바이스의 이름 공간을 관리하기 위해 사용한다.
</pre>
### 주요 파일시스템 구조
<pre>
-> 데이터 저장 용도로 주로 사용하는 파일시스템은 EXT 파일시스템 계열의 ext4 파일시스템과 SGI사의 xfs 파일시스템을 주로 사용한다.
-> ext4 파일시스템 기본구조
    -> 파일시스템 전체에 대한 주요 정보는 슈퍼블록에 저장된다.
    -> ext4 파일시스템 내에 여러 개의 블록 그룹이 존재한다.
    -> 슈퍼 블록의 백업이 일부 블록 그룹에 저장된다.
    -> inode를 사용하여 파일의 메타정보와 데이터를 분리하여 저장한다.
-> xfs 파일시스템 기본구조
    -> inode를 사용한다. 내부 구조는 ext4 파일시스템과 같지 않다.
    -> ext4의 블록그룹 대신 할당 그룹 용어를 사용한다.
    -> 기본적으로 볼륨을 8개의 할당그룹으로 분할한다.
    -> 8개 이상으로 분할할 수 있다.
    -> 파일 탐색을 위해 B+트리를 사용한다.
</pre>
### 스왑 메모리
<pre>
-> 메모리 확보를 위한 기법
-> mkswap file-name : 스왑 파일 생성
-> swapon [option] {partition | file-name} : 스왑 영역 활성화
-> swapoff [option] {partition | file-name | UUID } : 스왑 영역 활성화 해제
</pre>
# 8. 논리볼륨 관리
<pre>
-> 전통적인 디스크 파티셔닝은 장치의 설정이나 사이즈를 변경하는 작업이 어렵기 때문에 확장성이나 유연성 확보를 위한 작업
-> 논리 볼륨 구성
    -> 디스크 장치 - 물리 볼륨 - 볼륨 그룹 - 논리 볼륨
-> 논리 볼륨 생성
    -> 물리볼륨을 생성하기 위한 파티션 생성
       fdisk -l /dev/sdb 
       lvmdiskscan : 파티션정보 확인 
    -> 물리 볼륨 생성
       pcvreate partition1 partition2...
    -> 볼륨 그룹 구성
       vgcreate [option] volume-group-name physical-volume1 2...
       vgremove volume-group-name : 볼륨그룹 삭제 
    -> 논리 볼륨 생성
       lvcreate [option] volume-group-name
       lvremove logical-volume-path : 논리 볼륨 삭제
-> 스트라이프 볼륨(Striped Volume)
    -> 스토리지의 사이즈와 성능을 중시하는 논리 볼륨 생성 방식
-> 미러 볼륨
    -> 서비스 이상시 서비스가 중단되지 않고 정상적으로 서비스를 제공하며 데이터 손실을 방지하도록 하며 
       이러한 내결함성을 중시한 논리 볼륨 방식
-> RAID-5, RAID-6 볼륨
    -> 스트라이프 볼륨의 사이즈의 효율성으로 성능을 향상 시킬수 있고, 미러 볼륨만큼은 아니지만, 내결함성을 지원한다.
-> RAID-10 볼륨
    -> RAID-1 볼륨인 미러 볼륨을 먼저 구성하고, 생성된 미러 볼륨을 RAID-0 볼륨, 스트라이프 볼륨으로 연결하는 방식을 의미
</pre>
### 씬 프로비저닝 구성
<pre>
-> 볼륨의 크기를 실제 디스크에 할당되는 크기가 아닌 가상의 크기를 사용하는 방식
-> 씬 프로비저닝을 사용하여 논리 볼륨을 생성하면 볼륨 그룹에서 지정한 사이즈 전체를 바로 할당받지 않고,
   실제로 사용할 크기만큼만 사이즈를 할당받아 사용하다가 임계치에 도달하면 다시 볼륨의 사이즈를 증가시킨다.
</pre>
### 논리 볼륨 관련 명령어
<pre>
-> pvdisplay : 물리 볼륨 상태 확인
-> vgdisplay : 볼륨 그룹 상태 확인
-> lvdisplay : 논리 볼륨 상태 확인

-> 볼륨 그룹 확장
    -> vgextend volume-group-name physical-volume1 2...
-> 볼륨 그룹 축소
    -> vgreduce volume-group-name physical-volume1 2...
-> 논리 볼륨 확장
    -> lvextend [option] logical-volume-path
-> 논리 볼륨 축소
    -> lvreduce [option] logical-volume-path
-> 파일시스템 확장 명령어
    -> xfs_growfs mount-point
    -> resize2fs logical-volume-path
-> 파일시스템 축소 명령어\
    -> resize2fs logical-volume-path size
</pre>
# 9. Systemd
<pre>
-> 개요 : 기존의 init 프로세스를 대체하며 최신 리눅스에 도입되고 있는 새로운 PID 1번 프로세스이다.
          systemd는 시스템 관리, 로그 관리, 서비스 관리, 초기화 스크립트 관리 등의 시스템관리의 전반적인 작업을 수행한다.
-> ps- ef : 시스템에 동작중인 프로세스 목록중 systemd의 상태를 확인하는 명령어
-> systemd 기능 및 특징
    -> init 프로세스에 대한 호환성 제공
    -> systemd 유닛 사용
    -> 시스템 부팅 시 서비스 병렬 시작
    -> 사용자 요구에 맞게 서비스 실행
    -> 시스템 상태 스냅샷 지원
    -> 의존성 기반의 서비스 제어 로직 제공
    -> Upstart 대체
    -> CGroup(Contorl Group) 관리
    -> systemctl을 사용한 사용자 정의 명령 미지원
    -> systemd에 의해 실행된 서비스만 관리
    -> 시스템 셧다운 시 실행중인 서비스만 중지
    -> 서비스에 대해서 5분의 timeout 적용
    -> 소켓 기반 활성화
    -> 버스 기반 활성화
    -> 장치 기반 활성화
    -> 경로 기반 활성화
    -> 마운트 포인트와 자동마운트 포인트 관리
    -> 통합 로그 관리
</pre>
## system 유닛
<pre>
-> systemd 유닛 파일 위치
    -> /etc/systemd/system : 시스템 관리자가 수동으로 생성 및 관리하는 유닛들이 저장되는 디렉토리
    -> /run/systemd/system : 시스템이 런타임 상태일 때 임시로 유닛파일을 저장하는 디렉토리
    -> /usr/lib/systemd/system : 사용자가 패키지를 특정 유닛이 포함된 패키지를 설치하면 저장된느 디렉토리

-> systemd 유닛의 종류
    -> 확장자에 따라 유닛의 종류가 달라짐.
    -> 서비스 유닛, 장치 유닛, 마운트 유닛, 자동마운트 유닛, 스왑 유닛 등등..
</pre>

## systemctl 명령어 예제
<pre>
-> systemctl start 서비스명 : 서비스 시작
-> systemctl stop 서비스명 : 서비스 중지
-> systemctl enable unit-name : 유닛 활성화
-> systemctl status 서비스명 : 상태확인
-> systemctl list-units : 유닛의 실행 상태 확인
-> systemctl is-active unit-name : 특정 유닛의 실행 상태 확인
-> systemctl is-enabled unit-name : 특정 유닛의 활성화 상태 확인
-> systemctl list-dependencies unit-name : 특정 유닛의 의존성 확인
-> systemctl mask unit-name : 마스킹
-> systemctl unmask unit-name : 마스킹 해제
</pre>

# 10. 로그 관리
<pre>
-> 시스템에서 발생된 문제의 원인을 파악하거나 또는 인가되지 않은 접근으로부터 칩입 경로를 조회할 수 있다.
   systemd-journald를 통해서 시스템에서 발생한 모든 로그를 수집하고, 데이터 형식으로 관리한다.
-> system-journald에 의해서 수집되는 로그는 저널 데이터라고 부르며, /run/log/journal 디렉토리에 바이너리 파일 형태로 저장된다.
-> rsyslogd에 의해서 수집되는 로그의 파일 위치
    -> /var/log/messages : 대부분의 로그 기록
    -> /var/log/secure : 인증과 관련된 로그를 기록
    -> /var/log/mailog : 메일과 관련된 로그를 기록
    -> /var/log/cron : 주기적인 작업과 관련된 로그를 기록
    -> /var/log/boot.log : 부팅과정에 발생된 로그를 기록
-> rsyslogd
    -> 유닉스나 리눅스 계열 시스템에서 로그를 기록하기 위한 표준 프로토콜인 syslog를 사용하여 로그를 저장하는 프로세스이다.
       syslog에 비해 로그 전송 시 암호화옵션 등을 사용할 수 있어 보안이 강화되었고, 로그 처리 및 저장 성능이 우수하다.
-> /etc/rsyslog.conf
    -> 파일의 룰 부분에는 rsyslogd에 의해 전달되는 로그의 규칙들이 정의되어 있다.
-> 필터(Filter)
    -> 로그 메시지를 분류하기 위한 기준, 필터 조건에 따라 로그 메시지가 처리되는 방식을 결정할 수 있다.
-> 행동(Action)
    -> 필터에 의해서 선택된 로그들이 처리되는 방법을 정의하는 부분
       주로 파일에 메시지를 저장하거나, 시스템에 로그인된 사용자에게 메시지를 전달한다.
-> journalctl 명령어 : journalctl [option] [arg] : 저널 데이터 조회
</pre>

# 11. 리눅스 부트 프로세스 
<pre>
-> 부팅 절차 : BIOS/UEFI -> Boot Loader -> Kernel -> init -> Read inittab -> rc.sysinit -> runlevel1 2 3 ...
-> systemd 부팅 절차 : BIOS/UEFI -> Boot Loader -> Kernel -> systemd -> default.target -> grapgical.target ....
</pre>

# 10. 소프트웨어 패키지
<pre>
-> 개요 : 과거 리눅스에선 특정 소프트웨어를 설치하기 위해서는 아카이브 파일이나 압축파일로 되어 있는 파일에서 원본 소스 파일을 추출하고
          해당 파일을 컴파일하여 별도로 설치해야 하는 번거로운 작업 과정을 거쳐야 했다.
          그렇기 때문에 소프트웨어를 좀 더 쉽게 설치할 수 있는 방법이 필요했다.
          이 때 등장한 것이 바로 소프트웨어 패키지이다.
          
-> RPM(RedHat Package Manager)을 사용하여 패키지 관리
    -> RPM은 패키지를 관리하는 도구로써, 리눅스 사용자들이 보다 쉽게 소프트웨어 설치를 할 수 있도록 레드햇(RedHat)에서 개발한 방식이다.
    -> 근래에는 RPM은 설치에 사용하기 보다는 패키지에 대한 정보를 수집하거나 관리하는데 주로 사용되고 있다.
    -> 패키지 설치는 RPM보다는 YUM이라는 패키지 관리 도구를 주로 사용하고 있다.
    -> 패키지 확인 방법 : rpm -q [query-option[ [query-arg] 
    
-> YUM(Yellowdog Updater Modified)을 사용하여 패키지 관리
    -> YUM 저장소(repository)
        -> YUM 저장소는 패키지들을 저장해놓은 하나의 서버를 의미한다.
    -> yum subcommand [arg] : YUM 패키지 정보 확인
    -> yum [-y] install package-name : YUM 패키지 설치
    -> yum [-y] update [package-name] : YUM 패키지 업데이트
    -> yum [-y] remove package-name : YUM 패키지 제거
    -> yum groups subcommand [arg] : YUM 그룹 패키지
</pre>

# 13. 네트워크 
## 네트워크 관리
<pre>
-> ip address show [interface-name] : IP 정보 확인
   ifconfig [interface-name] 
-> ip route : 라우팅 테이블 확인
-> traceroute [option] destination : 목적지까지 가는 라우터 경로를 출력하는 명령어
-> nslookup [interface-name]: Domain의 IP를 조회하는 명령어
</pre>

## 네트워크 관리자
<pre>
-> 네트워크 관리자는 네트워크와 관련된 모든 설정을 관리하고 모니터링 하는 서비스이다.
   서비스 이름은 NetworkManager이며, systemd에서는 systemctl로 제어한다.
-> yum -y install NetworkManager : 네트워크 관리자 설치
   systemctl status NetworkManager : 네트워크 관리자를 설치한 뒤 서비스 확인

-> 레거시(Legacy) 네트워크 구성
    -> 기존 방식을 통한 네트워크 서비스 구성
    -> /etc/sysconfig/network-scripts : 설정 파일
    -> 레거시 네트워크 사용
        -> 기존 레거시 네트워크 사용을 하고싶다면 네트워크 관리를 중지 및 비활성화 해야함.
        -> systemctl stop NetworkManager 
        -> systemctl disable NetworkManager
        -> systemctl mask NetworkManager
        -> systemctl start network
        -> systemctl enable network
    -> 레거시 네트워크 설정
        -> /etc/sysconfig/network-scripts : ifcfg 파일 수정
    -> systemctl restart network : 변경후, 재시작
    -> ip address add ip/netmask dev interface-name : ip 명령을 사용하여 인터페이스에 IP 추가

-> 네트워크 관리자 도구 활용
    -> nmcli(Network Manager Command Line Interface)
        -> 네트워크 관리자가 제공하는 가장 강력한 커맨드 라인 도구
    -> nmcli connection show : 네트워크 연결 목록 확인
    -> nmcli connection add [subcommand1] [arg1] : 연결 생성
    -> nmcli connection delete connection-name : 연결설정 삭제
    -> nmcli connection modify connection-name subcommand arg : 연결 수정
    -> nmcli connection {up|down} connection-name : 설정 활성화/비활성화
</pre>

## 호스트이름 설정
<pre>
-> 개요 : 사용자는 다른 시스템과 통신하려면 대상 시스템의 IP주소를 알고 있어야 하지만, IP를 외우는 것은 매우 어렵다.
          따라서 주소로 변환하는 방식 DNS(Domain Name System) 서비스를 사용한다.
-> hostname : 시스템의 호스트이름을 확인
-> hostnamectl : 호스트이름의 정보를 확인
-> hostnamectl set-hostname hostname : 호스트이름 변경
</pre>

## OpenSSH(Open Secure Shell)
<pre>
-> 개요 :  관리자가 시스템을 관리할 때 직접 서버에서 접속하는 방식과 외부에서 네트워크를 통해 접속하는 방식이 있다.
           직접 서버에서 작업하는 경우는 서버의 모니터와 키보드를 직접 연결하여 사용하는 방식과 콘솔 연결방식으로 나누어진다.
           외부에서 네트워크를 통해 원격 접속할 때 사용하는 방식은 과거에는 텔넷(Telnet)이나 리모트쉘(rsh)을 사용했으며,
           근래에는 보안쉘(SSH)을 이용한 방식을 주로 사용하고 있다.
           SSH는 데이터 암호화할 때 비대칭 키 암호화와 대칭키 암호화 알고리즘을 사용한다.
-> ex) ssh user01@example.co.kr : example.co.kr 시스템의 user01로 원격 접속하는 예시

-> 연결과정
    -> 클라이언트는 서버에게 접속 요청
    -> 서버는 클라이언트에게 공개 키 전송
    -> 클라이어트는 비밀 키 생성
    -> 클라이언트는 비밀 키 암호화
    -> 클라이언트는 서버에 비밀 키 전송
    -> 서버는 비밀 키 복호화

-> /etc/ssh : OpenSSH의 구성 파일 위치
-> /etc/ssh/sshd_config : OpenSSH 서버 설정파일

-> OpenSSH 키 기반 인증
    -> 개요 : 원격접속 할 땐 기본적으로 사용자의 아이디나 패스워드를 알아야한다.
              하지만 키 기반 인증은 암호를 알고있지 않아도 접속이 가능하다.
    -> 키 파일 생성 : ssh-keygen [option] [arg] 
    -> 키 파일 복사 : ssh-copy-id [option] [arg] [user-name]@address 

-> 원격 파일 전송
    -> scp [option] source1 source2 ..dstination : scp(Secure Copy) 명어 사용, rcp를 대체하기 위한 명령어 rcp는 평문전송 이기때문에 대체하였다.
    -> sftp [user-name]@address : sftp 명령 사용
</pre>

# 14. NTP(Network Time Protocol) 서버 관리
<pre>
-> 개요 : NTP는 컴퓨터의 시스템의 시간을 동기화할 때 사용하는 프로토콜이다.

-> NTP 동작 방식
    -> 시간정보를 동기화시키고자 하는 클라이언트 NTP 서버로 정확한 시간정보 요청을 전송한다.
       이 때, 자신이 가지고 있는 정확하지 않은 시간 정보를 함께 전송한다.
    -> NTP 서버는 요청을 수신 후 응답을 준비한다.
    -> NTP 서버는 요청을 전송받은 정확한 시간정보와, 요청 수신 후 응답하는 정확한 시간정보를 포함한 정보를 응답한다.

-> NTP 계층 구조
    -> NTP 서버의 특징
        -> Stratum0 : 가장 상위 계층, Stratum 1에게 정확한 시간정보를 제공
        -> Stratum1 : Stratum0으로 부터 시간정보 수신 및 동기화, 일반적으로 Stratum2 서버 이외의 접근을 차단한다.
        -> Stratum2 : 일반적인 시간동기화 요청에 사용할 수 있는 최상위 NTP 서버
        -> Stratum n : 각각 자신보다 상위 단계의 서버로부터 시간을 동기화한다.
                       계층이 낮아질수록 시간정확도가 낮을 가능성이 높다.
</pre>

## chrony 서비스
<pre>
-> 이전 버전의 리눅스는 NTP서비스를 사용하기 위해 NTP 도구를 상요하여 시간동기화를 수행하였으나,
   최신 리눅스에서 chrony로 교체되었다.
-> /etc/chrony.conf : chronyd 서비스는 파일을 참조하여 동작환경을 설정한다.
-> chronyc tracking : 동기화 시간정보 확인
-> chronyc sources : 시간 소스 정보 확인
-> chronyc sourcestats : drift rate 및 offset 추정 정보 확인
-> ex) 설정변경
   -> chronyc
   -> add server ntp.ewha.or.kr
   -> authhash SHA1
   -> vi /etc/chronyc.conf : vi를 사용하여 영구 설정 변경
     -> systemctl restart chronyd : 서비스 재시작

-> 수동시간 설정
    -> 네트워크를 통해 NTP 서버에서 시간정보를 수신할 수 없는 경우, 또는 사용자가 임의로 시간을 변경하고 싶을 경우 date나 timedatectl를 사용
</pre>
# 15. 방화벽 관리
<pre>
-> 개요 : 리눅스 방화벽은 외부의 네트워크에서 내부의 시스템으로 접근하는 네트워크 패킷을 차단하는 서비스이다.
          리눅스에서 제공하는 방화벽은 Netfilter에 의해서 적용된다.
          Netfilter는 시스템에 접근하는 네트워크 패킷을 시스템 내부로 전달할지 아니면 폐기할지 결정하는 커널 모듈이다.
          사용자들이 Netfilter를 사용하여 네트워크 접근을 직접 제어하지 않고 서비스 관리 도구를 이용하여 제어한다.
</pre>
## firewalld
<pre>
-> firewalld는 systemd와 함께 도입된 방화벽 서비스이다.
   기존의 iptables의 한계와 단점을 보완한느 방화벽 서비스이다.
   iptables는 룰을 변경할 때 서비스를 중지해야 하기 때문에 네트워크 변화가 수시로 발생되는 오픈스택이나 가상화에서 사용할 때 제한적이다.
   하지만 firewalld는 동적으로 방화벽 설정을 변경할 수 있기 때문에 수시로 변하는 네트워크 변화에 대해 제한 없이 대응 할 수 있다는 장점이 존재한다.
-> /usr/lib/firewalld , /etc/firewalld : firewalld 서비스 설정 관련 파일, 기본 구성 대비용 적용되는 설정 파일
-> 동작 원리
    -> firewalld에서는 사전에 정의된 영역이 제공된다. 
       하지만 이 영역이 모두 사용되는 것은 아니고, 실제로는 활성화된 영역(Active Zone)만 사용된다.
       /etc/firewalld 디렉토리 내에 영역의 이름으로 된 XML파일이 존재하면 해당 영역은 활성화 영역이다.
       활성화 영역의 조건은 두가지 이다.
       -> 출발지의 주소(Source Address) 규칙 존재
       -> 연결되어 있는 인터페이스(Interface) 존재
-> 관련 명령어
    -> 상태 및 정보 확인 옵션
        -> firewall-cmd --state : firewalld 실행 상태 확인
        -> firewall-cmd --get-zones :  사전에 정의된 영역 확인
        -> firewall-cmd --get-services : 사전에 정의된 서비스 확인
        -> firewall-cmd --get-active-zones : 활성화된 영역 확인
        -> firewall-cmd --get-default-zone : 기본 영역 확인
        -> firewall-cmd --list-all --zone=home : 설정된 규칙 확인
    -> 규칙 설정 옵션
        -> firewall-cmd --set-default-zone=home : 기본 영역 설정
        -> firewall-cmd --add-interface=ens37 --zone=hone : 특정 영역에 인터페이스 연결 추가
        -> firewall-cmd --change-interface=ens37 --zone=hone : 영역에 연결된 인터페이스 변경
        -> firewall-cmd --add-source=192.168.0.0/24 --zone=public --permanent : 출발지 주소 규칙 추가
        -> firewall-cmd --remove-source=192.168.0.0/24 : 출발지 주소 규칙 제거
-> 리치 규칙(Rich Rule)
    -> firewall-cmd에서 제공하는 명령으로 대부분의 규칙 설정을 할 수 있지만 세부적인 설정을 수정하는 기능이 부족하다.
       firewalld에서 방화벽 규칙을 세부적으로 설정할 때 사용되는 것.
</pre>

# 16. 네트워크 티밍
<pre>
-> 개요 : 일반적인 네트워크 구성은 하나의 인터페이스에 하나의 IP주소를 설정하는 것이다.
          하지만, 티밍 구성은 여러 개의 물리 인터페이스를 묶어 하나의 논리 인터페이스를 구성하고 이 논리 인터페이스에 IP주소를 부여하는 방식이다.
          이러한 티밍 구성을 하는 이유는 대역폭을 늘려 데이터 처리량을 높여주거나, 부하분산을 통해 효율성을 높이고,
          트래픽 처리 속도를 향상시킬 수 있고, 네트워크 인터페이스에 장애 발생 시 좀 더 안전한 네트워크 구성을 위해 설정한다.
       
-> 네트워크 티밍 구성 방식:
    -> 포트 트렁킹(Port Trunking)
    -> 링크 집계(Link Aggregation)
    -> 채널 본딩(Channel Bonding)
    -> 이더넷 본딩(Ethernet Bonding)
    -> 채널 티밍(Channel Teaming)
    -> NIC 티밍(NIC Teaming)

-> 부가설명 : 리눅스에서는 예전부터 이런 구성을 본딩(Bonding) 이라고 하였으며,
             최신 엔터프라이즈 리눅스에서는 기존의 본딩 방식과는 별개로 티밍 방식을 제공한다. 
             물론 여전히 기존 본딩 방식으로 네트워크를 구성할 수 있다.
             네트워크 티밍의 장점은 새롭게 설계된 커널 모듈로서 팀 인터페이스로 유입되는 트래픽을 더 빠르게 처리하거나,
             LACP(Link Aggregation Control Protocol)를 완벽하게 지원하며, IPv6 링크 모니터링 및 D-Bus 인터페이스까지 지원한다.
             또한 본딩의 동작은 커널 영역에서 이뤄지지만, 티밍은 사용자 영역에서 동작하기 때문에 쉽게 관리하고 운영이 가능하다.
</pre>

## 티밍(teaming)
<pre>
-> 여러 개의 물리적인 인터페이스를 하나의 논리적인 인터페이스로 구성하는 네트워크 구성 방식이다.
-> 여기에서 사용되는 물리적인 인터페이스를 티밍에서는 슬레이브 혹은 포트 인터페이스라고 부르고, 
   해당 인터페이스들의 묶음인 논리적인 인터페이스를 마스터 혹은 팀 인터페이스라고 한다.
-> 이러한 물리적인 인터페이스인 포트 인터페이스는 실질적으로 데이터가 이동하는 통로 역할을 수행하게 되며,
   가상의 인터페이스인 팀 인터페이스에는 데이터의 처리 방식과 통신에 사용할 IP주소와 같은 논리적인 구성이 포함되는 인터페이스이다.
-> 티밍이 활성화되려면 팀 인터페이스에 연결된 포트 인터페이스들이 활성화되어야 한다.
-> 티밍은 팀 인터페이스에 IP주소를 부여할 수  있는데 이 때 IP주소를 DHCP서버에서 동적으로 할당 받을 수 도 있고, 정적 설정도 가능하다.
-> 만약 동적으로 IP 주소로 할당받으려면 포트 인터페이스는 반드시 네트워크에 연결되어 있어야 한다.
   정적 IP 설정은 포트 인터페이스가 연결되기 전에 설정할 수 있지만 동작하지 않는다.
</pre>
## 러너(Runner)
<pre>
-> 티밍은 설정에 따라 트래픽 처리 방식이 달라지는데 여기에서 처리 방식을 결정해주는 것이 러너이다.
-> 러너는 그 설정에 따라 데이터 처리량을 높여주거나, 효율성을 높이고 처리 속도를 향상시킬 수도 있고,
   네트워크 연결에 장애가 발생했을 때 끊어짐 없이 안정적인 서비스를 제공할 수 있도록 네트워크를 구성할 수 있다.
-> 처리방식
    -> broadcast : 모든 포트로 데이터 전송
    -> roundRobin : 각 포트로 순차적 데이터 전송
    -> loadbalance : 부하분산 방식의 패킷 전송
    -> activebackup : 장애조치를 위한 설정
    -> lacp : LACP 구현 스위치 기능상의 지원이 필요
</pre>
## 티밍(teaming)과 본딩(Bonding)
<pre>
-> 공통점 : 모두 대역폭의 확장이나 부하분산, 장애조치와 같은 목적을 위해 
           여러 개의 물리적인 네트워크를 묶어 하나의 논리적인 네트워크 인터페이스를 구성한다.
-> 차이점 : 본딩(Bonding)은 동작 레벨이 커널 레벨(Kernel level)에서의 드라이버 제어였다면
            티밍(teaming)은 사용자 레벨(User level)에서의 동작 제어와 설정을 제공하기 때문에
            기존의 드라이버에 영향을 미치지 않는 새로운 방식이다.
            티밍은 사용자 레벨에서 동작하면서 Team Netlink API라는 도구를 통해 드라이버를 관리한다.
-> 요약
    -> 티밍을 사용하면 기존에 본딩으로 구성할 때보다 훨씬 편리하고 유연하게 설정할 수 있다.
       또한 모듈 방식으로 제공하기 때문에 확장성이 좋고 성능 면에서도 더 나은 성능을 기대할 수 있다.
    -> 티밍의 장점
        -> 유저 레벨의 동작으로 유연성 및 패킷 처리량이 향상
        -> 사용자가 해시함수를 지정할 수 있다.
        -> IPv6에 대한 모니터링이 가능해졌다.
        -> 포트간의 우선순위를 지정할 수 있다.
        -> 오버헤드가 낮아져 성능이 향상되었다.
</pre>
# 17. 리눅스 보안(SELinux : Security Enhanced Linux)
<pre>
-> 개요 : 과거 리눅스 시스템을 비롯하여 유닉스 계열의 시스템은 일반사용자들에게는 제한적인 권한을 부여했지만
          관리자인 root에게 너무나도 막강한 권한이 있어 외부의 공격자들에 의한 지속적인 권한 탈취 문제가 야기 되었고,
          관리자의 실수로 인해 다양한 장애 등이 발생할 수 있는 위험에 노출되었다.
          따라서, 사용자별 접근통제 및 제어를 통해 시스템을 보호할 필요가 생겼고,
          기존에도 다양한 방법으로 접근 통제를 수행했으나 접근 통제 관리의 여러 제한들 때문에 리눅스에서는 SELinux를 통해
          시스템을 접근 제어를 구현한다.
          
-> 소개 : SELinux는 강제 접근 제어 모델인 MAC(Mandatory Access Control)모델을 사용하여 시스템의 보안을 강화하는 리눅스 커널 모듈이다.
</pre>
## 접근 제어 모델
<pre>
-> 주체(Subject) : 시스템의 자원에 접근하는 프로세스 또는 사용자
-> 객체(Object) : 파일 또는 포트와 같은 시스템의 자원을 의미

-> DAC(Discretionary Access Control)모델
    -> 사용자가 임의로 객체에게 권한을 부여하여 객체에 대한 접근을 제어하기 때문에 임의 접근 제어 모델이라고 한다.
    -> DAC 모델에서 주체는 객체에 대한 권한만 설정되어 있다면 접근 할 수 있다.
-> MAC(Mandatory Access Control) 모델
    -> 주체와 객체에 부여된 보안 레이블과 정책 허용 스위치에 의해서 접근을 제어한다. 강제 접근 제어 모델이라고 한다.
    -> 주체가 객체에 접근할 때 먼저 객체에 접근할 수 있는 권한이 있는지 확인한 후 (DAC 모델에 적용한 후)에 보안 레이블을 확인한다.
-> RBAC(Role Based Access Control) 모델
    -> 역할기반의 접근 제어 모델이다. 역할은 다수의 권한을 묶어 놓은 그룹이다.
       관리자는 이 역할을 사용자에게 부여함으로써 권한을 제어한다.
</pre>

## SELinux
<pre>
-> 접근 제어 모델로 MAC 모델을 사용한다.
   따라서 보안 레이블(context)과 정책 허용 스위치(Boolean)가 사용된다.
-> SELinux를 활성화하면 모든 프로세스와 파일에 컨텍스트가 부여되며 프로세스가 파일에 접근할 때 프로세스의 컨텍스트가 
   파일의 컨텍스트에 접근할 수 있는 정책이 설정되어 있는지 확인한다.
   만약, 접근할 수 없다면 부울을 조절하여 접근을 허용할 수 있는지 확인한 뒤 부울을 활성화 해야한다.
</pre>
### SELinux 모드
<pre>
-> Disabled 모드
    -> SELinux 커널 모듈을 메모리에 로드하지 않기 때문에 SELinux가 완전 비활성화 되어있는 상태.
    -> SELinux가 비활성화 되어있기 때문에 시스템은 DAC 모델을 사용하며
       프로세스가 파일에 접근할 때 파일에 부여된 권한을 기준으로 접근이 제어된다.
 
-> Enforing 모드
    -> SELinux 커널 모듈을 메모리에 로드한다. SELinux가 활성화되어 있으며, SELinux 정책을 강제한다.
    -> MAC 모델이 적용되며 프로세스가 파일에 접근할 때 권한과 컨텍스트, 부울 등을 확인하고 필요시 차단한다.
    
-> Permissive 모드
    -> SELinux 커널 모듈을 메모리에 로드한다. SELinux는 활성화 되어 있지만, SELinux 정책을 강제하지 않는다.
    -> 정책을 위반하였을 경우, 경고 메시지만 남기게 된다.
</pre>
### SELinux 포트 레이블
<pre>
-> SELinux가 활성화되면 서비스들이 사용하는 포트에도 레이블이 부여된다.
   따라서 서비스가 기본적으로 사용하는 포트 외의 것을 사용하려면 해당 포트에 포트 레이블을 부여해야 한다.
-> SELinux가 Enforcing 모드 일 때, 특정 서비스가 사용하는 기본 포트를 임의의 다른 포트로 변경하여 사용할 경우
   서비스가 정상적으로 제공되지 않을 수도 있다.
</pre>
### SELinux 문제 해결
<pre>
-> SELinux가 활성화된 시스템에서 서비스를 제공할 경우 관리자가 원하는 방향으로 설정되지 않아 해당 서비스를 이용하는 
   사용자가 정상적인 서비스를 이용하지 못할 수도 있다.
   SELinux가 활성화된 시스템에서 서비스를 원활하게 제공하려면 문제를 해결할 때 순서를 정해두고 진행하는 것이 좋다.
   -> 1. Permissive 모드 전환
   -> 2. 파일의 보안 레이블 확인
   -> 3. 포트 레이블 확인
   -> 4. 부울 확인
</pre>
# 18. DNS 서버
<pre>
-> 개요 : 인터넷에 연결되어 있는 모든 호스트들과 통신하려면 각 호스트의 IP주소를 알고 있어야 한다.
          하지만, IP 주소는 약 43억 개에 가까운 경우의 수를 가지고 있고, 이 주소가 호스트와 특별한 개연성없이 할당되어 있어,
          각 호스트의 IP 주소를 기억하기는 매우 어렵다.
          따라서, IP 주소 대신 기억하기 쉬운 이름을 사용하기 위해 DNS 서버에 이름에 해당하는 IP 주소를 요청한다.
</pre>
## DNS 동작 방식
<pre>
-> DNS 서버 한 대 에서 모든 DNS 정보를 처리하는 방식이 아닌, 계층적으로 이루어진 구조를 통해 단계별로 정보를 제공하고 있다.

-> 재귀 쿼리(Recursive Query):
    -> 사용자는 자신이 요청한 DNS 서버에게만 요청을 전송하고, 요청에 대한 응답을 수신한다.
       이렇게 이름 요청을 전송하고, 요청에 대한 정확한 응답을 수신하는 과정을 재귀 쿼리라고 한다.
       
-> 순환 쿼리(Iterative Query):
    -> 클라이언트의 요청을 수신한 DNS 서버는 요청을 처리하기 위하여 다른 DNS 서버로부터 단계적으로 질의하는 과정
 
-> 정방향 조회/ 역방향 조회
    -> DNS 서버는 호스트의 이름에 대한 요청을 수신한 후 요청한 이름에 대한 IP주소를 응답한다.
       이렇게 호스트이름을 IP주소로 변환해주는 DNS조회 방식이 정방향 조회이다.
       역방향 조회는 IP 주소에 대한 호스트이름을 요청할 경우 해당되는 호스트이름을 응답한다.

-> DNS 캐시
    -> DNS 요청은 시스템이 모르는 이름에 대한 IP 주소가 필요할 때 이루어진다.
       하지만, 최근 조회했던 내용을 다시 조회할 때는 DNS 요청이 발생하지 않을수도 있다.
       이미 시스템이 해당 이름에 대한 IP주소를 알고 있기 때문이다.
       이렇게 시스템이 기억하고 있는 이름과 IP 주소의 기록을 DNS 캐시라고 한다.
</pre>
# 19. DHCP(Dynamic Host Configuration Protocol) 서버
<pre>
-> 호스트의 네트워크 정보를 동적으로 할당하고 관리하는 응용계층 프로토콜
-> 개요 : IP 주소를 수동으로 설정하면 개별 시스템에 IP 설정을 해주어야 하고 때로는 관리자의 입력 실수,
          IP 주소의 충돌 같은 문제가 발생될 수 있다.
          이러한 단점을 보완하기 위한 방식이 DHCP 서버이다.
</pre>
## DHCP 동작방식
<pre>
-> 1. DHCP Discovery
    -> 새로 연결된 호스트가 DHCP 서버에게 사용할 수 있는 IP 주소와 네트워크 정보를 전달해 준 것을 요청한다. 브로드캐스트로 요청
-> 2. DHCP Offer
    -> DHCP 서버가 DHCP 요청에 응답하여 IP 할당을 제안하는 단계
       이 단계에서 IP 주소 및 네트워크에 대한 모든 정보가 호스트에게 전달된다.
-> 3. DHCP Request
    -> 복수의 DHCP 서버에게 DHCP Offer를 수신할 수 있으므로, 어떤 DHCP 서버로부터 전달받은 IP 주소를 사용할지 알린다.
       네트워크 내 모든 DHCP 서버가 수신할 수 있도록 브로드캐스트로 전송
-> 4. DHCP Acknowledge
    -> 이 단계에서는 DHCP 서버가 IP 주소를 임대했다는 정보를 저장하고, 호스트는 전달받은 IP 주소와 네트워크 정보를 사용한다.

-> DHCP 해제 방식 : DHCP Release (서버에 해제 요청)
</pre>
# 20. LDAP 기반 리눅스 시스템 인증 관리 - FreeIPA
<pre>
-> 디렉토리 서비스(LDAP)와 인증 서비스(Kerberos)가 함께 결합된 통합 솔루션이다.
-> FreeIPA는 이 두 가지 서비스에 DNS와 암호화를 위한 인증서 관리 솔루션 기능도 제공한다.
-> 즉, FreeIPA는 다수의 오픈소스 프로젝트가 모여서 만들어진 통합 식별 및 인증 솔루션이다.
-> 오픈소스 목록
    -> 디렉토리 서비스 : 389 Directory Server
    -> 인증 서비스 : MIT Kerberos KDC
    -> 인증서 관리 : Dogtag
    -> DNS 서비스 : Bind
    -> 웹 인터페이스 : Apache, Python
-> FreeIPA를 사용하면 ID 관리와 인증을 동시에 처리할 수 있다.
-> 네트워크를 통해 회사 또는 일상에서 사용하는 서비스 대부분은 다수의 시스템으로 구성되어 있고,
   개별 시스템에 각각 로그인을 해야하는 번거로움이 발생한다.
   하지만, FreeIPA를 이용하면 한번 로그인한 사용자는 각 서비스를 사용할 때 다시 로그인하지 않아도 된다.
   이를 우리는 일반적으로 SSO(Single Sign On)이라고 한다.
</pre>

## LDAP 프로토콜
<pre>
-> 경량 디렉토리 접근 프로토콜이라는 이름으로 클라이언트가 네트워크를 통해 
   디렉토리 서비스를 제공하는 디렉토리 서버에 저장된 정보에 접근할 때 사용하는 프로토콜이다.
-> LDAP는 이전 버전의 프로토콜인 X.500 또는 DAP(Directory Access Protocol)보다 쉽고 빠르게 동작한다.
   DAP는 ISO를 기준으로, LDAP는 TCP/IP를 기반으로 개발되어 있다.
</pre>

## 커버로스(Kerberos) 인증서비스
<pre>
-> 네트워크에 존재하는 시스템 간의 사용자 인증에 가장 많이 사용되는 인증 서비스로 사용자를 인증할 때 대칭키를 사용한다.
   커버로스 인증을 사용하면 네트워크를 통해 패스워드를 전송하지 않기 때문에 악의적으로 네트워크를 모니터링 하는 사용자를 차단할 수 있는 
   장점이 존재한다.
-> 커버로스는 네트워크 환경에서 통합된 인증서비스를 제공하며, SSO(Single Sign On)을 지원한다.
-> 커버로스 통합 인증
    -> 디렉토리 서비스와 커버로스를 사용하여 사용자와 인증 정보를 중앙에서 관리하고 각 서버는 사용자와 인증 정보를 인증이 필요할 때마다
       중앙의 서버에 받아오면 자원을 더 효율적으로 관리할 수 있다.
</pre>

# 21. FTP(File Transfer Protocol) 서버
<pre>
-> 개요 : TCP 기반으로 연결된 네트워크를 통해 원격 파일을 전송할 수 있는 방식으로 파일의 확인 및 다운로드가 가능하다.
          설정에 따라 서버로의 업로드도 가능한 프로토콜이다.
-> 특징 : 동작 방식이 매우 단순하고 직관적이며, 그만큼 사용하기도 쉽고 편리하다.
          그리고 대용량 파일을 빠르게 전송할 수 있지만 암호화하여 전송하지 않기 때문에 
          네트워크를 모니터링하는 악의적인 사용자에게 노출될 수 있다.
</pre>
## 연결 포트 
<pre>
-> FTP가 기본적으로 사용하는 포트는 20번과 21번이며, 서로 다른 역할을 수행한다.
    -> 20번 포트 : 데이터 포트라 하며, 데이터 전송에 사용되는 포트이다.
    -> 21번 포트 : 제어 포트라고 하며, 클라이언트의 접속 및 제어에 사용되는 포트이다.
    
-> 데이터 포트(20번 포트)
    -> 데이터 포트는 동작모드에 따라 다른 포트를 사용하는데, 
       액티브 모드(Active Mode)로 사용하면 20번 포트를 사용,
       패시브 모드(Passive Mode)로 동작하면 1024번 이상의 포트 중에 임의의 포트를 지정하여 사용한다.
    -> 연결된 이후에 파일을 전송할 때에만 연결하고 사용하지 않을 경우에는 폐쇄한다.
    
-> 제어 포트(21번 포트)
    -> 제어 포트로 사용하는 21번 포트는 상대방의 연결을 기다리거나,
       연결을 시도하고 다른 장치와 연결을 맺고 명령어 입력 시에 해당 명령어를 전달하는 데에 사용한다.
    -> 이 포트는 반이중(Half Duplex) 전송방식을 사용하기 땜누에 한번에 한쪽 방향으로만 통신이 가능하다.
</pre>

## 보안(vsftp: Very Secure FTP)
<pre>
-> FTP는 데이터를 네트워크에 평문으로 전송하기 때문에 네트워크를 악의적으로 네트워크를 도청하는 사용자에게 노출될 수 있는 단점이 존재한다.
   그래서 기본으로 제공되는 FTP이외에 보안적인 요소가 추가된 FTPS(FTP Secure, FTP-SSL), SFTP(Secure FTP) 등을 사용하는 것을 권장한다.
   FTPS는 기존의 전송 방식에서 TLS 또는 SSL을 사용한 암호화 통신을 지원하고,
   SFTP는 SSH 프로토콜을 사용하여 연결하기 때문에 암호화된 데이터로 통신할 수 있다.
</pre>

## 동작 모드
### 액티브 모드(크게 2단계로 나눔)
<pre>
-> 1. 클라이언트에서 서버 측으로의 요청이다. 이 단계에서 클라이언트는 서버가 사용하는 제어 포트인 21번 포트로 연결을 시도하며
      클라이언트는 서버에 연결할 데이터 포트 정보를 서버에게 전달하게 된다.
      이 때, 클라이언트가 사용하는 제어 포트와 데이터 포트번호는 잘 알려진 포트번호가 아닌 포트 번호 1024번 이상을 사용한다.
-> 2. 서버 측에서 클라이언트 측으로 직접 연결을 시도한다.
      이 때 서버는 기본 데이터 포트인 20번 포트를 사용하고, 이 포트를 통해서 클라이언트에서 전달받은 등록된 포트 번호로 연결을 시도한다.

-> 액티브 모드 특징 :
    -> 액티브 모드의 가장 큰 특징 중 하나는 TCP/IP의 서비스들과 달리 서버에서 클라이언트로 연결을 시도한다는 점이다.
       이로 인해 서버에 연결 할 때 서버의 방화벽뿐만 아니라 클라이언트의 방화벽에 의해 연결이 거부되는 경우도 많이 발생한다.
       또한, 방화벽 이외에도 요즘 가정 또는 회사에서 널리 사용되고 있는 공유기와 같이 외부에서의 접속을 허용하지 않거나
       NAT를 이용한 통신은 액티브 모드의 FTP 서비스를 정상적으로 사용할 수 없다.
       그러므로, 액티브 모드는 요즘 많이 사용하지 않으며, 이것을 해결하기 위하여 패시브 모드가 만들어졌다.
</pre>
### 패시브 모드(크게 3단계로 나눔)
<pre>
-> 1. 클라이언트에서 서버로의 연결 요청이다. 패시브 모드에서도 액티브 모드와 마찬가지로 서버의 제어 포트인 21번 포트로 연결을 요청한다.
-> 2. 서버에서 클라이언트로 서버가 사용할 데이터 포트 정보를 전달한다.
      이 때, 서버가 클라이언트에게 전달하는 데이터 포트 정보는 서버의 등록된 포트 중 하나를 사용한다.
-> 3. 클라이언트는 클라이언트가 사용할 데이터 포트를 통해서 서버가 전달한 데이터 포트로 연결을 시도하고,
      연결이 정상적으로 완료되면 데이터를 전송한다.
-> 패시브 모드 특징 :
    -> 액티브 모드의 문제점을 해결하기 위해 만들어진 방식 가장 큰 차이점은 FTP서버에 연결할 때 클라이언트에서 서버로 연결한다는 점이다.
    -> 패시브 모드는 액티브 모드에서의 두 가지 문제점은 해결했지만, 서버의 모든 비특권 포트에 대한 방화벽 설정을 해제해야 하는 문제가 존재한다.
       이 문제를 해결하기 위해 다양한 FTP 데몬들은 패시브 모드에서 사용하는 포트의 범위를 제한하는 것과 같은 추가적인 설정으로
       이 문제를 해결한다.
</pre>

# 22. NFS(Network File System) 스토리지
<pre>
-> 개요 : 윈도우의 공유 폴더처럼 파일을 공유하여 사용할 수 있어 파일의 일관성을 유지할 수 있는 분산 파일 시스템 프로토콜이다.
          NFS 서버를 구성하여 로컬에 존재하는 파일을 공유할 수 있으며, 파일을 공유할 때 접근할 수 있는 호스트 목록을 지정한다.
          또한, 커버로스와 함께 사용하여 인증, 무결성 검증, 암호화 통신을 사용할 수 있다.
          NFS를 사용하면 공유된 파일에 데이터를 보관하여 서로 다른 시스템에서 동일 데이터를 접근할 수 있기 때문에
          데이터의 일관성을 유지할 수 있다.
          또한, 규모가 큰 소프트웨어를 배포할 때 시스템의 부하를 감소시킨다.
          버전 NFSv3, NFSv4 버전을 지원하고 있다.
</pre>

## NFSv3
<pre>
-> NFSv3 특징 : 
    -> NFSv3은 안전한 비동기식 쓰기를 지원하여 쓰기 성능이 이전 버전보다 향상되었다.
    -> NFSv2 에 비해 에러 처리 능력이 향상되었다.
    -> 64bit 파일 사이즈 및 오프셋을 지원하여 2GB 이상의 파일에 접근이 가능
    -> RPC(Remote Procedure Call)에 의존된다. 따라서 rpcbind 서비스가 필요하다.
    -> NFS 서버의 공유 디렉토리에 대한 잠금 및 마운팅을 지원하기 위해 별도의 서비스가 함께 사용된다.
    -> NFSv3와 관련된 서비스가 다양하기 때문에 방화벽 설정이 복잡하다.

-> NFSv3 관련된 서비스
    -> NFSv3은 rpcbind 서비스에 의해 제어된다. 또한 관련된 다수의 서비스가 함께 실행되어야만 NFS 서버를 구성할 수 있다.
    -> nfs : 공유된 NFS 서버에 대한 요청을 처리하기 위하여 NFS 서버와 적절한 RPC 프로세스를 실행한다.
    -> nfslock : NFS 서버의 파일을 클라이언트가 잠금할 수 있도록 하는 서비스
    -> rpcbind : 로컬 RPC 서비스로부터 포트를 예약한다.
                 rpcbind는 RCP 서비스에 대한 요청에 응답하고 요청된 RPC 서비스로 연결을 설정한다.
    -> rpc.mountd : 이 프로세스는 NFSv3로 부터 마운트 요청을 처리하기 위해 NFS 서버에서 사용된다.
                    또한, 요청된 공유 디렉토리가 현재 NFS 서버에서 export 파일에 등록되었는지 확인한다.
    -> rpc.nfsd : 이 프로세스는 NFS 버전과 프로토콜이 정의되도록 하며 NFS 서비스의 사용자 레벨을 제공한다.
                  주요 기능은 nfsd 커널 모듈에 의해 처리된다.
    -> lockd : 서버와 클라이언트 모두에서 실행되는 커널 쓰레드이다. 
               이 프로세스는 NLM(Network Lock Manager) 프로토콜을 제공하며, NFSv3 클라이언트가 서버의 파일을 잠글수 있도록 한다.
    -> rpc.statd : 이 프로세스는 NSM(Network Status Monitor) RPC 프로토콜을 제공한다.
                   이는 NFS 서버가 정사적으로 종료되지 않고 재시작 될 때 NFS 클라이언트에게 NFS 서버가 비정상적으로 종료되었다는 정보를 전달한다.
    -> rpc.rquotad : 이 프로세스는 원격 사용자에게 사용자 할당 정보를 제공한다.
</pre>

## NFSv4
<pre>
-> NFSv4의 특징
    -> rpcbind를 사용하지 않고 서버 자체가 2049/TCP 포트에서 대기한다.
    -> 마운팅과 잠금 프로토콜은 NFSv4 프로토콜로 통합되어 별개의 서비스를 요구하지 않아서, 방화벽 구성을 쉽게 할 수 있다.
    -> NFS 서버의 성능이 향상되었고, 보안 기능 또한 강화되었다.
    -> pNFS(Parallel NFS)를 사용할 수 있다.
    -> 이전 버전의 NFS서버와 하위호환되어 동작한다.

-> NFSv4 관련된 서비스
    -> rpc.mountd : NFS 서버에서 export를 설정하기 위해 필요하다.
    -> nfs-server : NFS 서버의 파일 시스템을 공유하는 시스템이다.
    -> rpc.idmapd : 이 프로세스는 NFSv4 ID와 이름을 연결한다.
                    UID 또는 GID를 이름으로 전환하거나 반대로 전환하는 기능을 제공한다.
</pre>

# 23. SMB(Server Message Block) 스토리지
<pre>
-> 개요 : 윈도우 계열 시스템에서 파일을 공유할 때 사용하는 서비스이다.
          이 때, 통신에 사용되는 프로토콜이 SMB 프로토콜이기 때문에 SMB 스토리지 라고 한다.
          SMB 스토리지는 윈도우에서 구성한 뒤 리눅스에서 연결이 가능하며
          반대로, 리눅스에서 구성한 뒤 윈도우에서도 연결할 수 있다.
          
-> SMB 프로토콜은 TCP/IP 위에서 동작하며, 로컽 네트워크가 아닌 다른 네트워크에 존재하는 시스템에서 공유하는 디렉토리에는 접근할 수 없다.
   이러한 문제점으로 인해 CIFS(Common Internet File System) 프로토콜이 개발되었는데,
   CIFS 프로토콜은 SMB 프로토콜과 결합하여 사용할 수 있는 SMB 확장 프로토콜이다.
   CIFS 프로토콜을 사용하면 네트워크가 다른 시스템에서 공유하는 디렉토리에서도 접근이 가능하다.
</pre>

## 삼바(Smaba)
<pre>
-> 개요 : 삼바(Samba)는 Dos PC에 유닉스 서버의 디스크를 마운트하기 위하여, MS사의 SMB를 패킷 스니퍼 프로그램을 이용하여
          리버스 엔지니어링하여, 유닉스 시스템에 SMB 프로토콜을 구현하는 것으로 시작되었고,
          지금 현재 윈도우, 리눅스, 맥 등 이기종 시스템 간에 SMB/CIFS/NetBIOS 프로토콜을 이용해 데이터를 공유하는 프로젝트로 발전하게 되었다.

-> 사용자는 삼바를 사용하여 SMB 스토리지를 공유하거나 SMB 공유를 사용할 수 있으며,
   로컬 네트워크에 프린트를 공유하거나 공유 중인 프린트에도 연결하여 사용할 수 있다.
   
-> 장점 :
    -> 리눅스/유닉스 또는 윈도우 운영체제 클라이언트에게 디렉토리와 프린트 제공
    -> NetBIOS를 사용하여 네트워크의 공유 스토리지 탐색
    -> 윈도우 도메인에 로그인하여 인증

-> 삼바와 관련된 데몬
    -> smbd : smbd 서버 데몬은 윈도우 클라이언트에게 파일과 프린트 서비스를 제공한다.
              또한, SMB 프로토콜을 통하여 사용자 인증, 리소스 잠금, 자료 공유를 담당한다.
    -> nmbd : nmbd 서버 데몬은 윈도우 기반 시스템에서 SMB/CIFS에 의해 생성된 NetBIOS 이름 서비스 요청에 대해서 인식하고 응답한다.
    -> winbind : winbind 서비스는 윈도우 계열의 서버로부터 받은 사용자와 그룹 정보를 유닉스/리눅스 시스템이 이해할 수 있도록 해결한다.

* 데몬 : 주기적인 서비스 요청을 처리하기 위해 계속 실행되는 프로그램
</pre>

# 24. ISCSI(Internet Small Computer System Interface)
<pre>
-> 컴퓨팅 환경에서 데이터 스토리지 시설을 이어주는 IP 기반의 스토리지 네트워킹 표준
-> 구성 방식으로 DAS, NAS, SAN 방식이 존재한다.
</pre>
## DAS(Direct Attached Storage)
<pre>
-> 스토리지 장치와 시스템과 케이블을 통해 직접 연결되는 방식
-> 네트워크 연결이 없이 간편하게 사용할 수 있는 방식으로 처리속도가 빠른 ATA, SATA, SCSI, SAS 등의 케이블을 사용한다.
-> 직접 케이블을 연결해야 하기 때문에 공간적인 제약이 존재한다.
-> 가격이 저렴하고 확장이 용이하고 네트워크 연결이 없어 보안에 좀 더 유리하다는 장점으로 인해 여전히 많은 곳에서 사용되고 있다.
</pre>
## NAS(Network Attached Storage)
<pre>
-> 네트워크를 통해 연결도니 스토리지 장치를 의미하고 이 방식은 다른 두 방식과는 달리 파일 단위의 공유를 사용한다.
-> 기존에 파일공유 및 파일 서비스를 제공하는 파일서버에서 몇 가지 단점을 보완한 발전형이라고 볼 수 있다.
   현재도 계속 사용 중이지만 파일서버는 범용 OS를 사용하면서 서버로서 파일을 제공한다.
   그래서, 파일을 공유하는 부분에서 큰 문제는 없었지만 갈수록 파일의 크기가 커지고 높은 대역폭과 속도를 요구하는데 있어서
   따라가기 힘든 문제가 존재하였다.
   이런 파일서버가 갖는 문제점을 극복한 방식이 NAS(Network Attached Storage)이다.
-> NAS는 파일 단위로 접근해서 사용할 수 있도록 특화된 전용 파일 서버로 파일 I/O에 최적화된 서버이다.
</pre>
## SAN(Storage Area Network)
<pre>
-> NAS와 네트워크를 사용하는 점은 동일하지만 SAN 방식은 네트워크 연결에 있어서 스토리지 전용으로 사용하는 네트워크를 별도로 가진다.
   따라서 별도의 연결망을 이용하기 때문에 신뢰성이 높고 처리 속도가 빨라진다.
-> NAS 방식은 파일기반 스토리지이지만, SAN 방식은 블록기반 스토리지이다.
</pre>
### SAN 방식
<pre>
-> FC-SAN
    -> 초기에는 파이버 채널(Fiber Channel,FC)을 이용한 FC-SAN방식을 주로 사용했다.
    -> SAN에서 말하는 FC 방식은 광섬유를 사용하는 방식이다.
       광섬유를 사용하면 손실이 적고 대역폭을 크게 늘릴 수 있지만, 케이블 및 주변장치를 모두 교체해야하기 때문에 초기 비용이 크게 발생한다.
       이러한 비용적인 문제로 인해 IP-SAN방식을 많이 사용하고 있다.
      
-> IP-SAN
    -> 여러 가지 방식이 존재 AoE, FCoE, ISCSI 등이 있다.
       보통 ISCSI 방식을 채택하여 많이 사용한다.
</pre>

### 스토리지 저장방식
<pre>
-> 파일기반 스토리지
    -> 파일서버나 NAS방식에서 사용하는 방식이다.
       제공하는 대상이 파일단위로 검색 및 접근하게 되고 일반적으로 우리가 사용하는 계층적 파일시스템 구조를 갖고 있다.
       따라서 사용자는 대상의 계층구조 안에서 추가적인 파일검색 및 전송 등의 작업을 할 수 있다.

-> 블록기반 스토리지
    -> DAS, SAN 등의 스토리지 연결방식에서 사용하는 방식
       이 방식은 제공하는 대상을 파일이 아닌 블록 디바이스로 제공하고 접근하게 된다.
       따라서 접근하는 사용자는 해당 스토리지를 일반적인 디스크장치처럼 인식하고 사용할 수 있다.
       즉, 제공받은 블록 스토리지를 파티셔닝하고 파일시스템을 생성하여 사용할 수 있는 방식이다.
</pre>

### ISCSI 용어 설명
<pre>
-> 기본 용어
    -> 타겟(Target) : 스토리지 장치를 제공하는 시스템으로 서버 역할을 하는 시스템
    -> 초기자(initiator) : 타겟에서 제공하는 스토리지 장치에 연결해서 블록 스토리지를 제공받는 클라이언트 시스템
    -> IQN(ISCSI Qualitied Name) : 타겟과 초기자의 이름
    
-> 타겟(Target)에서의 용어
    -> TPG(Target Portal Group): 대상 포털 그룹으로서 ACL, LUN, Portal 세 항목을 하나의 그룹으로 만든 연결에 대한 설정
    -> ACL(Access Control List): 접근 제어 리스트로서 타겟에 의해 제공되는 스토리지에 연결할 수 있는 초기자를 지정하는 항목
    -> LUN(Logical Unit Number): 초기자에게 제공할 스토리지 장치에게 부여된 논리 장치 번호
    -> Portal : 초기자가 타겟에 연결할 때 사용하는 IP 주소와 포트번호
  
-> 초기자의 용어
    -> Discovery : 초기자에서 연결하려는 대상을 검색하기 위한 단계
    -> Login : Discovery에서 발견한 대상으로 연결하는 
</pre>
